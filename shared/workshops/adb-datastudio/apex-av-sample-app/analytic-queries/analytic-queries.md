# Examine Analytic Queries that Select from Tables


## Introduction

As an Oracle APEX developer, writing or generating the SQL used by reports, charts, and other items and regions is your job.  SQL for a simple report or chart is relatively easy.  But what about SQL for building an interactive, analytic application?  That is much more difficult.  Let's take a look.

Estimated Time:  5 minutes.

### Objectives

In this lab, you will:

- Examine and run queries that aggregate data and include analytic expressions.

### Prerequisites:

- Complete the previous lab.

## Task 1 - Aggregate Data to Year, Continent, and Search Genre

If you have been building reports and charts in APEX, it is almost certain that you have written queries like this to aggregate data.  You proabably used APEX items to parameterize filters, as shown in the commented line.

~~~SQL
<copy>
SELECT
    t.year
  , c.continent
  , sg.genre_name
  , round(AVG(f.list_price), 2)       AS avg_list_price
  , round(AVG(f.discount_percent), 2) AS avg_discount_percent
  , SUM(f.sales)                      AS sales
  , SUM(f.quantity)                   AS quantity
FROM
    time_dim         t
  , customer_dim     c
  , search_genre_dim sg
  , movie_sales_fact f
WHERE
        t.day_id = f.day_id
    AND c.customer_id = f.cust_id
    AND sg.genre_id = f.genre_id
    --- AND sg.genre_name = :P1_GENRE_NAME
    AND sg.genre_name = 'Documentary'
GROUP BY
    t.year
  , c.continent
  , sg.genre_name
ORDER BY
    t.year
  , c.continent
  , sg.genre_name;
</copy>
~~~

## Task 2 - Aggregate Data to Quarter, Country, and Search Genre

To change the report to query different levels of aggregation, you need to provide a new query.  While the query follows the same pattern, most columns have changed.  To allow the user to select the levels of aggregation interactively, the query would need to be generated by a PL/SQL function.  The difficulty level has increased significantly by offering this interactivity in the application.

~~~SQL
<copy>
SELECT
    t.quarter
  , c.country
  , sg.genre_name
  , round(AVG(f.list_price), 2)       AS avg_list_price
  , round(AVG(f.discount_percent), 2) AS avg_discount_percent
  , SUM(f.sales)                      AS sales
  , SUM(f.quantity)                   AS quantity
FROM
    time_dim         t
  , customer_dim     c
  , search_genre_dim sg
  , movie_sales_fact f
WHERE
        t.day_id = f.day_id
    AND c.customer_id = f.cust_id
    AND sg.genre_id = f.genre_id
    -- AND sg.genre_name = :P1_GENRE_NAME
    AND sg.genre_name = 'Documentary'
GROUP BY
    t.quarter
  , c.country
  , sg.genre_name
ORDER BY
    t.quarter
  , c.country
  , sg.genre_name;
  </copy>
  ~~~

## Task 3 - Prior Period Queries

Consider a percent change in sales from prior period calculation as an example of an analytic query.  The query runs in three passes:

1.  Aggregate sales to the required levels.
1.  Calculate the lag (prior period) of sales.
1.  Calculate the percent change in sales.

In the second pass, we must carefully account for the possibility of no sales in the prior period, requiring a partitioned outer join on time.

~~~SQL
<copy>
WITH sum_sales AS (
    -- First pass aggregates sales
    SELECT
        t.year
      , c.continent
      , sg.genre_name
      , SUM(f.sales) AS sales
    FROM
        time_dim         t
      , customer_dim     c
      , search_genre_dim sg
      , movie_sales_fact f
    WHERE
            t.day_id = f.day_id
        AND c.customer_id = f.cust_id
        AND sg.genre_id = f.genre_id
        AND sg.genre_name = 'Documentary'
    GROUP BY
        t.year
      , c.continent
      , sg.genre_name
), year_dim AS (
    -- A dense list of time periods to be joined to the second pass.
    SELECT DISTINCT
        year
    FROM
        time_dim
), sales_prior_period AS (
    -- Second pass densifies time periods and calculates the prior period of sales.
    SELECT
        a.year
      , a.continent
      , a.genre_name
      , a.sales
      , LAG(a.sales)
          OVER(PARTITION BY a.continent, a.genre_name
               ORDER BY
                   b.year ASC
        ) AS sales_prior_period
    FROM
        sum_sales a
        PARTITION BY ( a.continent
                     , a.genre_name ) RIGHT OUTER JOIN (
            SELECT DISTINCT
                b.year
            FROM
                year_dim b
        )         b ON ( a.year = b.year )
)
-- Third pass calculates the percent change in sales from the prior period.
SELECT
    year
  , continent
  , genre_name
  , sales
  , (sales - sales_prior_period) / sales_prior_period AS sales_pct_change_prior_period
FROM
    sales_prior_period;
</copy>
~~~

As an APEX developer, this query is yours to write or generate.  That can be a tremendous amount of work.
There must be a better way!

You may now **proceed to the next lab**

## Acknowledgements

- Created By/Date - William (Bud) Endress, Product Manager, Autonomous Database, June 2023
- Last Updated By - William (Bud) Endress, May 2024

Data about movies in this workshop were sourced from **Wikipedia**.

Copyright (C)  Oracle Corporation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled [GNU Free Documentation License](files/gnu-free-documentation-license.txt)